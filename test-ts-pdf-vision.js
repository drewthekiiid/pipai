#!/usr/bin/env node
/**
 * Test TypeScript PDF to Images conversion
 * Verifies pdftoppm + ImageMagick integration via child processes
 */

const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

async function testPDFToImages() {
  console.log('ğŸ§ª Testing TypeScript PDF â†’ Images conversion...');
  
  const testFile = 'WEN GNG40_Fall2024_PDF_V1 2.pdf';
  
  if (!(await fileExists(testFile))) {
    console.log(`âŒ Test file not found: ${testFile}`);
    return false;
  }
  
  const tempDir = await fs.mkdtemp('/tmp/ts-pdf-test-');
  console.log(`ğŸ“ Using temp directory: ${tempDir}`);
  
  try {
    // Step 1: Convert PDF to images with pdftoppm
    console.log('ğŸ”„ Step 1: Converting PDF to images with pdftoppm...');
    const imageFiles = await convertWithPdftoppm(testFile, tempDir);
    
    if (imageFiles.length === 0) {
      throw new Error('No images generated by pdftoppm');
    }
    
    console.log(`âœ… Generated ${imageFiles.length} images`);
    
    // Step 2: Optimize first image with ImageMagick
    console.log('ğŸ¨ Step 2: Optimizing image with ImageMagick...');
    const firstImage = imageFiles[0];
    const optimizedPath = path.join(tempDir, 'optimized_' + path.basename(firstImage));
    
    await optimizeWithImageMagick(firstImage, optimizedPath);
    console.log(`âœ… Optimized: ${path.basename(optimizedPath)}`);
    
    // Step 3: Get image dimensions
    console.log('ğŸ“ Step 3: Getting image dimensions...');
    const dimensions = await getImageDimensions(optimizedPath);
    console.log(`âœ… Dimensions: ${dimensions.width}x${dimensions.height}`);
    
    // Step 4: Show file sizes
    const originalSize = (await fs.stat(firstImage)).size;
    const optimizedSize = (await fs.stat(optimizedPath)).size;
    const reduction = ((originalSize - optimizedSize) / originalSize * 100).toFixed(1);
    
    console.log(`ğŸ“Š Size comparison:`);
    console.log(`   Original: ${(originalSize / 1024 / 1024).toFixed(2)}MB`);
    console.log(`   Optimized: ${(optimizedSize / 1024 / 1024).toFixed(2)}MB`);
    console.log(`   Reduction: ${reduction}%`);
    
    return true;
    
  } catch (error) {
    console.error(`âŒ Test failed: ${error.message}`);
    return false;
  } finally {
    // Cleanup
    try {
      await fs.rm(tempDir, { recursive: true, force: true });
      console.log(`ğŸ§¹ Cleaned up temp directory`);
    } catch (cleanupError) {
      console.warn(`âš ï¸ Cleanup failed: ${cleanupError.message}`);
    }
  }
}

async function fileExists(filePath) {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

function convertWithPdftoppm(pdfPath, workDir) {
  return new Promise((resolve, reject) => {
    const outputPrefix = path.join(workDir, 'page');
    const args = [pdfPath, outputPrefix, '-png', '-r', '300'];
    
    console.log(`ğŸ”§ Running: pdftoppm ${args.join(' ')}`);
    
    const process = spawn('pdftoppm', args, {
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    let stderr = '';
    
    process.stderr.on('data', (data) => {
      stderr += data.toString();
    });
    
    process.on('close', async (code) => {
      if (code !== 0) {
        reject(new Error(`pdftoppm failed with code ${code}: ${stderr}`));
        return;
      }
      
      try {
        const files = await fs.readdir(workDir);
        const imageFiles = files
          .filter(file => file.startsWith('page-') && file.endsWith('.png'))
          .map(file => path.join(workDir, file))
          .sort();
        
        resolve(imageFiles);
      } catch (error) {
        reject(error);
      }
    });
    
    process.on('error', (error) => {
      reject(new Error(`Failed to start pdftoppm: ${error.message}`));
    });
  });
}

function optimizeWithImageMagick(inputPath, outputPath) {
  return new Promise((resolve, reject) => {
    const args = [
      inputPath,
      '-resize', 'x1998>', // Resize if taller than 1998px
      '-quality', '85',
      '-strip',
      '-colorspace', 'sRGB',
      outputPath
    ];
    
    const process = spawn('magick', args, {
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    let stderr = '';
    
    process.stderr.on('data', (data) => {
      stderr += data.toString();
    });
    
    process.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`ImageMagick failed with code ${code}: ${stderr}`));
        return;
      }
      resolve();
    });
    
    process.on('error', (error) => {
      reject(new Error(`Failed to start ImageMagick: ${error.message}`));
    });
  });
}

function getImageDimensions(imagePath) {
  return new Promise((resolve, reject) => {
    const args = ['-ping', '-format', '%w %h', imagePath];
    
    const process = spawn('magick', ['identify', ...args], {
      stdio: ['pipe', 'pipe', 'pipe']
    });
    
    let stdout = '';
    let stderr = '';
    
    process.stdout.on('data', (data) => {
      stdout += data.toString();
    });
    
    process.stderr.on('data', (data) => {
      stderr += data.toString();
    });
    
    process.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`ImageMagick identify failed: ${stderr}`));
        return;
      }
      
      const dimensions = stdout.trim().split(' ');
      if (dimensions.length >= 2) {
        resolve({
          width: parseInt(dimensions[0], 10),
          height: parseInt(dimensions[1], 10)
        });
      } else {
        reject(new Error(`Failed to parse dimensions: ${stdout}`));
      }
    });
    
    process.on('error', (error) => {
      reject(new Error(`Failed to start ImageMagick identify: ${error.message}`));
    });
  });
}

// Run the test
testPDFToImages().then(success => {
  if (success) {
    console.log('\nâœ… TypeScript PDF â†’ Images test PASSED');
    console.log('ğŸš€ Ready for unified language deployment!');
    console.log('ğŸ¯ Benefits:');
    console.log('   - All TypeScript/JavaScript codebase');
    console.log('   - Best-in-class pdftoppm + ImageMagick tools');
    console.log('   - No Python dependencies');
    console.log('   - Perfect for Docker deployment');
  } else {
    console.log('\nâŒ TypeScript PDF â†’ Images test FAILED');
    process.exit(1);
  }
}); 